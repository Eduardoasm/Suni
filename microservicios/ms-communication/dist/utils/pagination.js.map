{"version":3,"file":"pagination.js","sourceRoot":"/","sources":["utils/pagination.ts"],"names":[],"mappings":";;;;AAqBA;;;;;;;;;;GAUG;AACH,SAAsB,aAAa,CACjC,IAAY,EACZ,OAAe,EACf,KAAQ,EACR,SAAyB,EAAE,EAC3B,aAAuC,IAAI,EAC3C,UAAkC,EAAE;;QAEpC,MAAM,KAAK,GAAG,MAAM,KAAK,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;QACjD,MAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,CAAC;QAC7C,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,GAAG,OAAO,CAAC,CAAC;QACzC,MAAM,QAAQ,GACZ,IAAI,GAAG,SAAS;YACd,CAAC,CAAC,EAAE;YACJ,CAAC,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,UAAU,kCAC9B,CAAC,OAAO,aAAP,OAAO,cAAP,OAAO,GAAI,EAAE,CAAC,KAClB,IAAI,EACJ,KAAK,EAAE,OAAO,IACd,CAAC;QACT,OAAO;YACL,KAAK;YACL,KAAK,EAAE,QAAQ;YACf,QAAQ,EAAE;gBACR,WAAW,EAAE,IAAI;gBACjB,OAAO;gBACP,SAAS;gBACT,SAAS,EAAE,KAAK;gBAChB,eAAe,EAAE,IAAI,GAAG,CAAC;gBACzB,WAAW,EAAE,QAAQ,CAAC,MAAM,GAAG,OAAO,IAAI,IAAI,GAAG,OAAO,GAAG,KAAK;aACjE;SACF,CAAC;IACJ,CAAC;CAAA;AA/BD,sCA+BC;AAED,SAAgB,mBAAmB,CAAC,KAAa;IAC/C,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,MAAM,IAAI,SAAS,CAAC,4CAA4C,CAAC,CAAC;KACnE;IACD,MAAM,IAAI,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;IACjE,OAAO;WACE,IAAI;;gBAEC,IAAI;kBACF,IAAI;;WAEX,IAAI;;;;;;;;GAQZ,CAAC;AACJ,CAAC;AApBD,kDAoBC","sourcesContent":["import type {\n  Model,\n  Document,\n  FilterQuery,\n  ProjectionType,\n  QueryOptions,\n} from 'mongoose';\n\nexport type Pagination<T> = {\n  count: number;\n  items: T[];\n  pageInfo: {\n    currentPage: number;\n    perPage: number;\n    itemCount: number;\n    pageCount: number;\n    hasPreviousPage: boolean;\n    hasNextPage: boolean;\n  };\n};\n\n/**\n * @function paginateModel\n * @description This function recibe a model and execute all the logic for pagination\n * @param {number} page - actual page\n * @param {number} perPage - items per page\n * @param {Model<any>} model - mongoose model\n * @param {FilterQuery<any>} filter - filter query\n * @param {ProjectionType<any>} projection - projection\n * @param {QueryOptions<any>} options - options\n * @returns {Pagination<Document<any>>} - pagination object\n */\nexport async function paginateModel<T extends Model<any>, U extends Document>(\n  page: number,\n  perPage: number,\n  model: T,\n  filter: FilterQuery<T> = {},\n  projection: ProjectionType<T> | null = null,\n  options: QueryOptions<T> | null = {}\n): Promise<Pagination<U>> {\n  const count = await model.countDocuments(filter);\n  const pageCount = Math.ceil(count / perPage);\n  const skip = Math.max(0, page * perPage);\n  const products =\n    page > pageCount\n      ? []\n      : await model.find(filter, projection, {\n          ...(options ?? {}),\n          skip,\n          limit: perPage,\n        });\n  return {\n    count,\n    items: products,\n    pageInfo: {\n      currentPage: page,\n      perPage,\n      pageCount,\n      itemCount: count,\n      hasPreviousPage: page > 1,\n      hasNextPage: products.length > perPage || page * perPage < count,\n    },\n  };\n}\n\nexport function buildPaginationType(_name: string) {\n  if (typeof _name !== 'string') {\n    throw new TypeError('buildPaginationType: name must be a string');\n  }\n  const name = `${_name.charAt(0).toUpperCase()}${_name.slice(1)}`;\n  return `\n    type ${name}Pagination {\n      count: Int!\n      items: [${name}]!\n      pageInfo: ${name}PageInfo!\n    }\n    type ${name}PageInfo {\n      currentPage: Int\n      perPage: Int\n      itemCount: Int\n      pageCount: Int\n      hasPreviousPage: Boolean\n      hasNextPage: Boolean\n    }\n  `;\n}\n"]}