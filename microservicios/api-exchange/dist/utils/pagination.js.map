{"version":3,"file":"pagination.js","sourceRoot":"/","sources":["utils/pagination.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  Model,\n  Document,\n  FilterQuery,\n  ProjectionType,\n  QueryOptions,\n  AggregateOptions,\n  PipelineStage,\n} from 'mongoose';\n\nexport type Pagination<T> = {\n  count: number;\n  items: T[];\n  pageInfo: {\n    currentPage: number;\n    perPage: number;\n    itemCount: number;\n    pageCount: number;\n    hasPreviousPage: boolean;\n    hasNextPage: boolean;\n  };\n};\n\n/**\n * @function paginateModel\n * @description This function recibe a model and execute all the logic for pagination\n * @param {number} page - actual page\n * @param {number} perPage - items per page\n * @param {Model<any>} model - mongoose model\n * @param {FilterQuery<any>} filter - filter query\n * @param {ProjectionType<any>} projection - projection\n * @param {QueryOptions<any>} options - options\n * @returns {Pagination<Document<any>>} - pagination object\n */\nexport async function paginateModel<T extends Model<any>, U extends Document>(\n  page: number,\n  perPage: number,\n  model: T,\n  filter: FilterQuery<T> = {},\n  projection: ProjectionType<T> | null = null,\n  options: QueryOptions<T> | null = {}\n): Promise<Pagination<U>> {\n  const count = await model.countDocuments(filter);\n  const pageCount = Math.ceil(count / perPage);\n  if (page > pageCount) {\n    throw new Error('No hay más páginas disponibles');\n  }\n  const skip = Math.max(0, (page - 1) * perPage);\n  const products = await model.find(filter, projection, {\n    ...(options ?? {}),\n    skip,\n    limit: perPage,\n  });\n  return {\n    count,\n    items: products,\n    pageInfo: {\n      currentPage: page,\n      perPage,\n      pageCount,\n      itemCount: count,\n      hasPreviousPage: page > 1,\n      hasNextPage: products.length > perPage || page * perPage < count,\n    },\n  };\n}\n\nexport function buildPaginationType(_name: string) {\n  if (typeof _name !== 'string') {\n    throw new TypeError('buildPaginationType: name must be a string');\n  }\n  const name = `${_name.charAt(0).toUpperCase()}${_name.slice(1)}`;\n  return `\n    type ${name}Pagination {\n      count: Int!\n      items: [${name}]!\n      pageInfo: ${name}PageInfo!\n    }\n    type ${name}PageInfo {\n      currentPage: Int\n      perPage: Int\n      itemCount: Int\n      pageCount: Int\n      hasPreviousPage: Boolean\n      hasNextPage: Boolean\n    }\n  `;\n}\n\nexport async function paginateModelAggregation<\n  T extends Model<any>,\n  U extends Document\n>(\n  page: number,\n  perPage: number,\n  model: T,\n  pipeline: PipelineStage[] = [],\n  projection: ProjectionType<T> | null = null,\n  options: QueryOptions<T> | null = {}\n): Promise<Pagination<U>> {\n  const startIndex = (page - 1) * perPage;\n\n  const endIndex = page * perPage;\n\n  const countAggregate = model.aggregate(pipeline).count('total');\n  const documentsAggregate = model\n    .aggregate(pipeline)\n    .skip(startIndex)\n    .limit(perPage);\n\n  // if (projection) {\n  //   documentsAggregate.projection(projection);\n  // }\n\n  // if (options) {\n  //   documentsAggregate.options(options);\n  // }\n\n  const [countResult, documents] = await Promise.all([\n    countAggregate.exec(),\n    documentsAggregate.exec(),\n  ]);\n\n  const count = countResult[0]?.total || 0;\n\n  const pageCount = Math.ceil(count / perPage);\n  if (page > pageCount) {\n    throw new Error('No hay más páginas disponibles');\n  }\n\n  return {\n    count,\n    items: documents,\n    pageInfo: {\n      currentPage: page,\n      perPage,\n      pageCount,\n      itemCount: count,\n      hasPreviousPage: page > 1,\n      hasNextPage: documents.length > perPage || page * perPage < count,\n    },\n  };\n}\n\nexport async function paginate<T>(\n  page: number,\n  perPage: number,\n  items: any[]\n): Promise<Pagination<T>> {\n  const count = items.length;\n  const pageCount = Math.ceil(count / perPage);\n  if (page > pageCount) {\n    throw new Error('No hay más páginas disponibles');\n  }\n  const skip = Math.max(0, (page - 1) * perPage);\n  const startIndex = skip;\n  const endIndex = startIndex + perPage;\n  const slicedItems = items.slice(startIndex, endIndex);\n  return {\n    count,\n    items: slicedItems,\n    pageInfo: {\n      currentPage: page,\n      perPage,\n      pageCount,\n      itemCount: slicedItems.length,\n      hasPreviousPage: page > 1,\n      hasNextPage: endIndex < count,\n    },\n  };\n}\n"]}