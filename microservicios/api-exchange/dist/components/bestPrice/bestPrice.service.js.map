{"version":3,"file":"bestPrice.service.js","sourceRoot":"/","sources":["components/bestPrice/bestPrice.service.ts"],"names":[],"mappings":";;;;AAQA,uCAA4C;AAC5C,uDAA0D;AAC1D,2FAAqE;AAGrE,SAAsB,OAAO,CAC3B,MAAgC,EAChC,UAA8C,EAC9C,OAAyC;;QAEzC,OAAO,2BAAS,CAAC,OAAO,CAAC,MAAM,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC;IAC/D,CAAC;CAAA;AAND,0BAMC;AAED,SAAsB,IAAI,CACxB,MAAgC,EAChC,UAA8C,EAC9C,OAAyC;;QAEzC,OAAO,2BAAS,CAAC,IAAI,CAAC,MAAM,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC;IAC5D,CAAC;CAAA;AAND,oBAMC;AAED,SAAsB,SAAS,CAC7B,MAA+B,EAC/B,MAA+D,EAC/D,OAAyC;;QAEzC,OAAO,2BAAS,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC;IAC7D,CAAC;CAAA;AAND,8BAMC;AAED,SAAsB,MAAM,CAAC,SAAqB;;QAChD,OAAO,2BAAS,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;IACrC,CAAC;CAAA;AAFD,wBAEC;AAED,SAAsB,UAAU,CAC9B,IAAY,EACZ,OAAe,EACf,MAAgC,EAChC,UAA8C,EAC9C,OAAyC;;QAEzC,OAAO,IAAA,qBAAa,EAAC,IAAI,EAAE,OAAO,EAAE,2BAAS,EAAE,MAAM,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;IAC9E,CAAC;CAAA;AARD,gCAQC;AAED,SAAsB,YAAY,CAAC,IAAmB;;QACpD,MAAM,wBAAwB,GAAG,MAAM,cAAc,CAAC,OAAO,CAC3D;YACE,QAAQ,EAAE,IAAI,CAAC,UAAU;YACzB,KAAK,EAAE,IAAI,CAAC,OAAO;YACnB,KAAK,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE;SACrB,EACD,EAAE,EACF;YACE,IAAI,EAAE;gBACJ,KAAK,EAAE,CAAC,CAAC;aACV;SACF,CACF,CAAC;QAEF,MAAM,oBAAoB,GAAG,MAAM,cAAc,CAAC,OAAO,CACvD;YACE,QAAQ,EAAE,IAAI,CAAC,UAAU;YACzB,KAAK,EAAE,IAAI,CAAC,OAAO;YACnB,KAAK,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE;SACrB,EACD,EAAE,EACF;YACE,IAAI,EAAE;gBACJ,KAAK,EAAE,CAAC;aACT;SACF,CACF,CAAC;QACF,8DAA8D;QAC9D,wFAAwF;QACxF,MAAM,SAAS,GAAG,MAAM,2BAAS,CAAC,gBAAgB,CAChD,EAAE,QAAQ,EAAE,IAAI,CAAC,UAAU,EAAE,KAAK,EAAE,IAAI,CAAC,OAAO,EAAE,EAClD;YACE,iBAAiB,EAAE,wBAAwB,aAAxB,wBAAwB,uBAAxB,wBAAwB,CAAE,KAAK;YAClD,aAAa,EAAE,oBAAoB,aAApB,oBAAoB,uBAApB,oBAAoB,CAAE,KAAK;SAC3C,EACD;YACE,MAAM,EAAE,IAAI;YACZ,GAAG,EAAE,IAAI;SACV,CACF,CAAC;QAEF,OAAO,SAAS,CAAC;IACnB,CAAC;CAAA;AA3CD,oCA2CC","sourcesContent":["/* eslint-disable import/no-cycle */\nimport type {\n  FilterQuery,\n  ProjectionType,\n  QueryOptions,\n  UpdateQuery,\n  UpdateWithAggregationPipeline,\n} from 'mongoose';\nimport { paginateModel } from '../../utils';\nimport { IBestPrice, BestPrice } from './bestPrice.model';\nimport * as listingService from '../listing/listing/listing.service';\nimport { TGetBestPrice } from './bestPrice.dto';\n\nexport async function findOne(\n  filter?: FilterQuery<IBestPrice>,\n  projection?: ProjectionType<IBestPrice> | null,\n  options?: QueryOptions<IBestPrice> | null\n) {\n  return BestPrice.findOne(filter, projection, options).exec();\n}\n\nexport async function find(\n  filter?: FilterQuery<IBestPrice>,\n  projection?: ProjectionType<IBestPrice> | null,\n  options?: QueryOptions<IBestPrice> | null\n) {\n  return BestPrice.find(filter, projection, options).exec();\n}\n\nexport async function updateOne(\n  filter: FilterQuery<IBestPrice>,\n  update: UpdateQuery<IBestPrice> | UpdateWithAggregationPipeline,\n  options?: QueryOptions<IBestPrice> | null\n) {\n  return BestPrice.updateOne(filter, update, options).exec();\n}\n\nexport async function create(bestPrice: IBestPrice) {\n  return BestPrice.create(bestPrice);\n}\n\nexport async function pagination(\n  page: number,\n  perPage: number,\n  filter?: FilterQuery<IBestPrice>,\n  projection?: ProjectionType<IBestPrice> | null,\n  options?: QueryOptions<IBestPrice> | null\n) {\n  return paginateModel(page, perPage, BestPrice, filter, projection, options);\n}\n\nexport async function getBestPrice(body: TGetBestPrice) {\n  const bestPricePurchaseListing = await listingService.findOne(\n    {\n      currency: body.currencyId,\n      asset: body.assetId,\n      price: { $ne: null },\n    },\n    {},\n    {\n      sort: {\n        price: -1,\n      },\n    }\n  );\n\n  const bestPriceSaleListing = await listingService.findOne(\n    {\n      currency: body.currencyId,\n      asset: body.assetId,\n      price: { $ne: null },\n    },\n    {},\n    {\n      sort: {\n        price: 1,\n      },\n    }\n  );\n  // upsert busqueda de bestPrice filtrando por currency y asset\n  // si consigue un modelBestPrice con el mismo currency o asset lo updatea si no, lo crea\n  const bestPrice = await BestPrice.findOneAndUpdate(\n    { currency: body.currencyId, asset: body.assetId },\n    {\n      purchaseBestPrice: bestPricePurchaseListing?.price,\n      saleBestPrice: bestPriceSaleListing?.price,\n    },\n    {\n      upsert: true,\n      new: true,\n    }\n  );\n\n  return bestPrice;\n}\n"]}